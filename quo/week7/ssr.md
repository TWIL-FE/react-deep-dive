# 서버 사이드 렌더링

## 서버 사이드 렌더링

### SPA

- 렌더링과 라우팅에 필요한 대부분의 기능을 서버가 아닌 브라우저의 JS에 의존하는 방식.
- 최초에 서버에서 최소한의 데이터를 불러온 이후부터는 이미 가지고 있는 JS 리소스와 브라우저 API를 기반으로 모든 작동이 이뤄진다.
- JS가 할 수 있는 게 많아지면서, 싱글 페이지 방식이 유행했다. 하지만 그만큼 처리해야하는 JS양이 많아져서 성능 개선은 눈에 띄게 좋아지지 않았다.
- 가장 뛰어난 SPA는 가장 뛰어난 MPA보다 낫다.

### SSR

- 최초에 사용자에게 보여줄 페이지를 서버에서 렌더링해 빠르게 사용자에게 화면을 제공한다.
- 장점
  - 최초 페이지 진입(FCP)이 비교적 빠르다.
  - 검색 엔진과 SNS 공유 등 메타데이터 제공이 쉽다.
  - 누적 레이아웃 이동(CLS)이 적다.
  - 사용자의 디바이스 성능에 비교적 자유롭다.
  - 민감 정보를 브라우저에 노출시키지 않아 보안에 좀 더 안전하다.
- 단점
  - 소스코드를 작성할 때 항상 서버를 고려해야한다.
  - 서버가 구축되어야 한다.
  - 서비스 지연에 따라 사용자에게 적절하게 보여줄 페이지가 렌더링되지 않을 수 있다.
- 평균적인 SPA는 평균적인 MPA보다 느리다.

## SSR을 위한 리액트 API

### renderToString

- 인수로 넘겨받은 리액트 컴포넌트를 렌더링해 HTML 문자열로 반환한다.
- 최초 페이지를 렌더링할 때 사용된다.
- 훅과 이벤트 핸들러는 결과물에 포함되지 않는다.
- div#root에는 data-reactroot 속성이 존재하며, 루트 엘리먼트가 무엇인지 식별하는 역할이다.

### renderToStaticMarkup

- renderToString과 매우 유사하지만, 리액트에서만 사용하는 추가적인 DOM 속성을 만들지 않는다. 순수한 HTML 문자열 반환.
- 이걸 기반으로 렌더링하면 훅이나 브라우저 API를 절대로 실행할 수 없다. hydrate 수행시 에러 발생.
- 정적인 내용만 렌더링하는 경우 유용하다.

### renderToNodeStream

- renderToString과 결과물이 동일하다.
- Node.js 서버 환경에서만 실행 가능하다.
- 결과물은 ReadableStream 타입이다. utf-8 인코딩된 바이트 스트림. ReadableStream은 브라우저에서 사용가능하나, 만드는 건 브라우저에서 불가능하다.
- 크기가 큰 결과물을 청크 단위로 분리해서 순차적으로 처리할 때 유용하다.

### renderToStaticNodeStream

- renderToNodeStream과 결과물은 동일하나, 리액트 속성이 제공되지 않는다. 순수 HTML 결과물이 필요할 때 사용한다.

### hydrate

- renderToString, renderToNodeStream으로 생성된 HTML 콘텐츠에 JS 핸들러나 이벤트를 붙인다.
- 서버에서 제공해 준 HTML이 클라이언트의 결과물과 같을 것이라는 가정 하에 실행된다.
- 불일치가 발생하면 경고를 하는데, 그럼에도 정상적으로 실행되는 이유는 렌더링한 기준으로 웹페이지를 그리기 때문이다.

## Next.js

페이지 라우터 기준.

### 프로젝트 구조

- next.config.js
  - reactStrictMode: 리액트 엄격 모드.
  - swcMinify: 번들링과 컴파일을 더 빠르게 하고 바벨의 대안인 swc의 코드 최소화 작업 여부.
  - bathPath: URL 접두사다.
  - redirects: 정규식을 사용해서 특정 주소를 다른 주소로 보낼 수 있다.
- \_app.tsx
  - 앱 페이지 전체를 초기화하는 곳이자, 전체 페이지의 시작점.
  - 최초 접근시에만 처리하고 싶은 작업을 수행할 수 있다.
- \_document.tsx: 앱의 HTML을 초기화하는 곳.
- \_error.tsx: 에러 처리하는 페이지. 잘 동작하는지 프로덕션 빌드에서 확인할 수 있다.
- 404.tsx: 404 페이지 처리.
- 500.tsx: 500 페이지 처리. \_error.tsx 보다 우선 순위에 있다.
- api/: 서버의 api를 정의하는 폴더. HTML 요청이 아닌, 단순 서버 요청을 주고 받음.

### Data Fetching

예약어로 지정된 함수명은 반드시 export를 사용해 함수를 파일 외부로 내보내야 한다.

- `getStaticPaths`, `getStaticProps`
  - 정적 페이지 렌더링시 사용.
  - 빌드 시점에 미리 데이터를 불러온다. 사용자는 페이지 렌더링을 기다릴 필요가 없어, 빠르게 페이지를 확인할 수 있다.
  - 데이터가 너무 많은 경우 fallback 옵션으로, 지연되는 동안 보여줄 페이지를 처리할 수 있다.
- `getServerSideProps`
  - 서버에서 실행되는 함수이며, 페이지 진입 전에 반드시 이 함수는 실행된다. 실행이 끝나기 전까지 사용자에게 어떠한 HTML도 보여 줄 수 없다.
  - 반환하는 props 값은 JSON으로 직렬화 가능한 타입으로 제한된다. class, Date 불가.
  - 조건에 따라 redirect가 가능하다.
- `getInitialProps`
  - 객체를 반환한다.
  - 라우팅에 따라서 서버와 클라이언트 모두에서 실행 가능하다.

### 스타일

- 전역 스타일
  - 앱 전체에 공통으로 적용하고 싶은 스타일은 \_app.tsx에서 직접 `import`한다.
- 컴포넌트 레벨 CSS
  - [name].module.css 네임 룰로, 컴포넌트에 상응하는 스타일을 정의할 수 있다.
- SCSS, SASS
  - 라이브러리를 설치해서 바로 사용할 수 있다.
- CSS-in-JS
  - JS 내부에 스타일 시트를 삽입하는 방식으로, 직관적이다.
  - 서버에서 스타일을 미리 모은 다음, 서버 사이드 렌더링에서 한꺼번에 제공해야 스타일을 적용할 수 있다. 에러가 발생하면 스타일 없는 HTML이 사용자에게 잠깐 노출되는 FOUC(flash of unstyled content)가 발생할 수 있다.
